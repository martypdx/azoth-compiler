{"version":3,"file":"findTemplates.js","sources":["../src/findTemplates.js"],"sourcesContent":["import parseTaggedTemplate from './parseTaggedTemplate';\nimport { ancestor, base } from 'acorn/dist/walk';\n\nconst noNestedTTE = Object.assign( base, { TaggedTemplateExpression(){} } );\n\nexport default function findTemplates( ast, tag ) {\n\tconst templates = [];\n\tancestor( ast, {\n\t\tTaggedTemplateExpression( node, ancestors ) {\n\t\t\tif( node.tag.name !== tag ) return;\n\t\t\tconst { html, bindings } = parseTaggedTemplate( node.quasi );\n\t\t\tconst scope = getFnScope( ancestors );\n\t\t\ttemplates.push( { html, bindings, scope, node } );\n\t\t}\n\t}, noNestedTTE );\n\treturn templates;\n}\n\nconst isFn = /function/i;\n\nfunction getFnScope( ancestors ) {\n\t// current child node is in stack, so -2\n\tlet i = ancestors.length - 2;\n\tlet node = null;\n\twhile( node = ancestors[i--] ) {\n\t\tif ( isFn.test( node.type ) ) return node;\n\t}\n}\n\n"],"names":[],"mappings":";;;;;kBAKwB;;AALxB;;;;AACA;;;;AAEA,MAAM,cAAc,OAAO,MAAP,aAAqB,EAAE,2BAA0B,CAAE,CAA9B,EAArB,CAApB;;AAEe,SAAS,aAAT,CAAwB,GAAxB,EAA6B,GAA7B,EAAmC;AACjD,OAAM,YAAY,EAAlB;AACA,qBAAU,GAAV,EAAe;AACd,2BAA0B,IAA1B,EAAgC,SAAhC,EAA4C;AAC3C,OAAI,KAAK,GAAL,CAAS,IAAT,KAAkB,GAAtB,EAA4B;AAC5B,SAAM,EAAE,IAAF,EAAQ,QAAR,KAAqB,mCAAqB,KAAK,KAA1B,CAA3B;AACA,SAAM,QAAQ,WAAY,SAAZ,CAAd;AACA,aAAU,IAAV,CAAgB,EAAE,IAAF,EAAQ,QAAR,EAAkB,KAAlB,EAAyB,IAAzB,EAAhB;AACA;AANa,EAAf,EAOG,WAPH;AAQA,QAAO,SAAP;AACA;;AAED,MAAM,OAAO,WAAb;;AAEA,SAAS,UAAT,CAAqB,SAArB,EAAiC;;AAEhC,KAAI,IAAI,UAAU,MAAV,GAAmB,CAA3B;AACA,KAAI,OAAO,IAAX;AACA,QAAO,OAAO,UAAU,GAAV,CAAd,EAA+B;AAC9B,MAAK,KAAK,IAAL,CAAW,KAAK,IAAhB,CAAL,EAA8B,OAAO,IAAP;AAC9B;AACD"}